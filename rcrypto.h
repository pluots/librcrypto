/*
* This file is automatically generated upon running
* `cargo +nightly build`. Do not modify by hand.
*/
#define X 100
#define RC_AEAD_AES128GCM_NONCEBYTES 12
#define RC_AEAD_AES128GCM_KEYBYTES 16
#define RC_AEAD_AES128GCM_MACBYTES 16
#define RC_AEAD_AES256GCM_NONCEBYTES 12
#define RC_AEAD_AES256GCM_KEYBYTES 32
#define RC_AEAD_AES256GCM_MACBYTES 16
#define RC_AEAD_CHACHA20POLY1305_NONCEBYTES 12
#define RC_AEAD_CHACHA20POLY1305_KEYBYTES 32
#define RC_AEAD_CHACHA20POLY1305_MACBYTES 16
#define RC_AEAD_XCHACHA20POLY1305_NONCEBYTES 24
#define RC_AEAD_XCHACHA20POLY1305_KEYBYTES 32
#define RC_AEAD_XCHACHA20POLY1305_MACBYTES 16
#define RC_SECRETBOX_KEYBYTES 24
#define RC_SECRETBOX_NONCEBYTES 32
#define RC_SECRETBOX_MACBYTES 16


#include <stdint.h>



#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Generate a nonce suitible for use with the
 *AES128-GCM
 * algorithm.
 */
void rc_aead_aes128gcm_noncegen(uint8_t nonce[RC_AEAD_AES128GCM_NONCEBYTES]);

/**
 * Generate a key suitible for use with the
 *AES128-GCM
 * algorithm.
 */
void rc_aead_aes128gcm_keygen(uint8_t key[RC_AEAD_AES128GCM_KEYBYTES]);

/**
 * Encrypt a message using the AES128-GCM algorithm.
 *
 * Returns 0 if successful, -1 otherwise. Parameters:
 *
 * - `msg`: an input and output buffer that will be encrypted
 * - `mlen`: length of the message to be encrypted
 * - `mac`: an output buffer where the authentecation tag will be written. Must be
 *   `RC_AEAD_AES128GCM_MACBYTES` bytes in length.
 * - `nonce`: a number used once, AKA initialization vector. This does not have to be
 *   confidential and can be stored with the message; however, it may not be reused
 *   for further encryption. Must be
 *   `RC_AEAD_AES128GCM_NONCEBYTES` bytes in length.
 * - `key`: the key used to encrypt the message. Must be
 *   `RC_AEAD_AES128GCM_KEYBYTES` bytes in length.
 *
 * # SAFETY
 *
 * `msg` must point to a valid buffer that is at least `mlen` in length.
 */
int8_t rc_aead_aes128gcm_encrypt(uint8_t *msg,
                                 uintptr_t mlen,
                                 uint8_t mac[RC_AEAD_AES128GCM_MACBYTES],
                                 const uint8_t nonce[RC_AEAD_AES128GCM_NONCEBYTES],
                                 const uint8_t key[RC_AEAD_AES128GCM_KEYBYTES]);

int8_t rc_aead_aes128gcm_encrypt_ad(uint8_t *msg,
                                    uintptr_t mlen,
                                    uint8_t mac[RC_AEAD_AES128GCM_MACBYTES],
                                    const uint8_t nonce[RC_AEAD_AES128GCM_NONCEBYTES],
                                    const uint8_t key[RC_AEAD_AES128GCM_KEYBYTES],
                                    const uint8_t *ad,
                                    uintptr_t adlen);

/**
 * Decrypt a message using the AES128-GCM algorithm.
 *
 * Returns 0 if successful, -1 otherwise. Parameters:
 *
 * - `msg`: an input and output buffer that will be decrypted
 * - `mlen`: length of the message to be decrypted
 * - `mac`: an output buffer where the authentecation tag will be written. Must be
 *   `RC_AEAD_AES128GCM_MACBYTES` bytes in length.
 * - `nonce`: a number used once, AKA initialization vector. This does not have to be
 *   confidential and can be stored with the message; however, it may not be reused
 *   for further encryption. Must be
 *   `RC_AEAD_AES128GCM_NONCEBYTES` bytes in length.
 * - `key`: the key used to encrypt the message. Must be
 *   `RC_AEAD_AES128GCM_KEYBYTES` bytes in length.
 *
 * # SAFETY
 *
 * `msg` must point to a valid buffer that is at least `mlen` in length.
 */
int8_t rc_aead_aes128gcm_decrypt(uint8_t *msg,
                                 uintptr_t mlen,
                                 const uint8_t mac[RC_AEAD_AES128GCM_MACBYTES],
                                 const uint8_t nonce[RC_AEAD_AES128GCM_NONCEBYTES],
                                 const uint8_t key[RC_AEAD_AES128GCM_KEYBYTES]);

int8_t rc_aead_aes128gcm_decrypt_ad(uint8_t *msg,
                                    uintptr_t mlen,
                                    const uint8_t mac[RC_AEAD_AES128GCM_MACBYTES],
                                    const uint8_t nonce[RC_AEAD_AES128GCM_NONCEBYTES],
                                    const uint8_t key[RC_AEAD_AES128GCM_KEYBYTES],
                                    const uint8_t *ad,
                                    uintptr_t adlen);

/**
 * Generate a nonce suitible for use with the
 *AES256-GCM
 * algorithm.
 */
void rc_aead_aes256gcm_noncegen(uint8_t nonce[RC_AEAD_AES256GCM_NONCEBYTES]);

/**
 * Generate a key suitible for use with the
 *AES256-GCM
 * algorithm.
 */
void rc_aead_aes256gcm_keygen(uint8_t key[RC_AEAD_AES256GCM_KEYBYTES]);

/**
 * Encrypt a message using the AES256-GCM algorithm.
 *
 * Returns 0 if successful, -1 otherwise. Parameters:
 *
 * - `msg`: an input and output buffer that will be encrypted
 * - `mlen`: length of the message to be encrypted
 * - `mac`: an output buffer where the authentecation tag will be written. Must be
 *   `RC_AEAD_AES256GCM_MACBYTES` bytes in length.
 * - `nonce`: a number used once, AKA initialization vector. This does not have to be
 *   confidential and can be stored with the message; however, it may not be reused
 *   for further encryption. Must be
 *   `RC_AEAD_AES256GCM_NONCEBYTES` bytes in length.
 * - `key`: the key used to encrypt the message. Must be
 *   `RC_AEAD_AES256GCM_KEYBYTES` bytes in length.
 *
 * # SAFETY
 *
 * `msg` must point to a valid buffer that is at least `mlen` in length.
 */
int8_t rc_aead_aes256gcm_encrypt(uint8_t *msg,
                                 uintptr_t mlen,
                                 uint8_t mac[RC_AEAD_AES256GCM_MACBYTES],
                                 const uint8_t nonce[RC_AEAD_AES256GCM_NONCEBYTES],
                                 const uint8_t key[RC_AEAD_AES256GCM_KEYBYTES]);

int8_t rc_aead_aes256gcm_encrypt_ad(uint8_t *msg,
                                    uintptr_t mlen,
                                    uint8_t mac[RC_AEAD_AES256GCM_MACBYTES],
                                    const uint8_t nonce[RC_AEAD_AES256GCM_NONCEBYTES],
                                    const uint8_t key[RC_AEAD_AES256GCM_KEYBYTES],
                                    const uint8_t *ad,
                                    uintptr_t adlen);

/**
 * Decrypt a message using the AES256-GCM algorithm.
 *
 * Returns 0 if successful, -1 otherwise. Parameters:
 *
 * - `msg`: an input and output buffer that will be decrypted
 * - `mlen`: length of the message to be decrypted
 * - `mac`: an output buffer where the authentecation tag will be written. Must be
 *   `RC_AEAD_AES256GCM_MACBYTES` bytes in length.
 * - `nonce`: a number used once, AKA initialization vector. This does not have to be
 *   confidential and can be stored with the message; however, it may not be reused
 *   for further encryption. Must be
 *   `RC_AEAD_AES256GCM_NONCEBYTES` bytes in length.
 * - `key`: the key used to encrypt the message. Must be
 *   `RC_AEAD_AES256GCM_KEYBYTES` bytes in length.
 *
 * # SAFETY
 *
 * `msg` must point to a valid buffer that is at least `mlen` in length.
 */
int8_t rc_aead_aes256gcm_decrypt(uint8_t *msg,
                                 uintptr_t mlen,
                                 const uint8_t mac[RC_AEAD_AES256GCM_MACBYTES],
                                 const uint8_t nonce[RC_AEAD_AES256GCM_NONCEBYTES],
                                 const uint8_t key[RC_AEAD_AES256GCM_KEYBYTES]);

int8_t rc_aead_aes256gcm_decrypt_ad(uint8_t *msg,
                                    uintptr_t mlen,
                                    const uint8_t mac[RC_AEAD_AES256GCM_MACBYTES],
                                    const uint8_t nonce[RC_AEAD_AES256GCM_NONCEBYTES],
                                    const uint8_t key[RC_AEAD_AES256GCM_KEYBYTES],
                                    const uint8_t *ad,
                                    uintptr_t adlen);

/**
 * Generate a nonce suitible for use with the
 *ChaCha20-Poly1305
 * algorithm.
 */
void rc_aead_chacha20poly1305_noncegen(uint8_t nonce[RC_AEAD_CHACHA20POLY1305_NONCEBYTES]);

/**
 * Generate a key suitible for use with the
 *ChaCha20-Poly1305
 * algorithm.
 */
void rc_aead_chacha20poly1305_keygen(uint8_t key[RC_AEAD_CHACHA20POLY1305_KEYBYTES]);

/**
 * Encrypt a message using the ChaCha20-Poly1305 algorithm.
 *
 * Returns 0 if successful, -1 otherwise. Parameters:
 *
 * - `msg`: an input and output buffer that will be encrypted
 * - `mlen`: length of the message to be encrypted
 * - `mac`: an output buffer where the authentecation tag will be written. Must be
 *   `RC_AEAD_CHACHA20POLY1305_MACBYTES` bytes in length.
 * - `nonce`: a number used once, AKA initialization vector. This does not have to be
 *   confidential and can be stored with the message; however, it may not be reused
 *   for further encryption. Must be
 *   `RC_AEAD_CHACHA20POLY1305_NONCEBYTES` bytes in length.
 * - `key`: the key used to encrypt the message. Must be
 *   `RC_AEAD_CHACHA20POLY1305_KEYBYTES` bytes in length.
 *
 * # SAFETY
 *
 * `msg` must point to a valid buffer that is at least `mlen` in length.
 */
int8_t rc_aead_chacha20poly1305_encrypt(uint8_t *msg,
                                        uintptr_t mlen,
                                        uint8_t mac[RC_AEAD_CHACHA20POLY1305_MACBYTES],
                                        const uint8_t nonce[RC_AEAD_CHACHA20POLY1305_NONCEBYTES],
                                        const uint8_t key[RC_AEAD_CHACHA20POLY1305_KEYBYTES]);

int8_t rc_aead_chacha20poly1305_encrypt_ad(uint8_t *msg,
                                           uintptr_t mlen,
                                           uint8_t mac[RC_AEAD_CHACHA20POLY1305_MACBYTES],
                                           const uint8_t nonce[RC_AEAD_CHACHA20POLY1305_NONCEBYTES],
                                           const uint8_t key[RC_AEAD_CHACHA20POLY1305_KEYBYTES],
                                           const uint8_t *ad,
                                           uintptr_t adlen);

/**
 * Decrypt a message using the ChaCha20-Poly1305 algorithm.
 *
 * Returns 0 if successful, -1 otherwise. Parameters:
 *
 * - `msg`: an input and output buffer that will be decrypted
 * - `mlen`: length of the message to be decrypted
 * - `mac`: an output buffer where the authentecation tag will be written. Must be
 *   `RC_AEAD_CHACHA20POLY1305_MACBYTES` bytes in length.
 * - `nonce`: a number used once, AKA initialization vector. This does not have to be
 *   confidential and can be stored with the message; however, it may not be reused
 *   for further encryption. Must be
 *   `RC_AEAD_CHACHA20POLY1305_NONCEBYTES` bytes in length.
 * - `key`: the key used to encrypt the message. Must be
 *   `RC_AEAD_CHACHA20POLY1305_KEYBYTES` bytes in length.
 *
 * # SAFETY
 *
 * `msg` must point to a valid buffer that is at least `mlen` in length.
 */
int8_t rc_aead_chacha20poly1305_decrypt(uint8_t *msg,
                                        uintptr_t mlen,
                                        const uint8_t mac[RC_AEAD_CHACHA20POLY1305_MACBYTES],
                                        const uint8_t nonce[RC_AEAD_CHACHA20POLY1305_NONCEBYTES],
                                        const uint8_t key[RC_AEAD_CHACHA20POLY1305_KEYBYTES]);

int8_t rc_aead_chacha20poly1305_decrypt_ad(uint8_t *msg,
                                           uintptr_t mlen,
                                           const uint8_t mac[RC_AEAD_CHACHA20POLY1305_MACBYTES],
                                           const uint8_t nonce[RC_AEAD_CHACHA20POLY1305_NONCEBYTES],
                                           const uint8_t key[RC_AEAD_CHACHA20POLY1305_KEYBYTES],
                                           const uint8_t *ad,
                                           uintptr_t adlen);

/**
 * Generate a nonce suitible for use with the
 *XChaCha20-Poly1305
 * algorithm.
 */
void rc_aead_xchacha20poly1305_noncegen(uint8_t nonce[RC_AEAD_XCHACHA20POLY1305_NONCEBYTES]);

/**
 * Generate a key suitible for use with the
 *XChaCha20-Poly1305
 * algorithm.
 */
void rc_aead_xchacha20poly1305_keygen(uint8_t key[RC_AEAD_XCHACHA20POLY1305_KEYBYTES]);

/**
 * Encrypt a message using the XChaCha20-Poly1305 algorithm.
 *
 * Returns 0 if successful, -1 otherwise. Parameters:
 *
 * - `msg`: an input and output buffer that will be encrypted
 * - `mlen`: length of the message to be encrypted
 * - `mac`: an output buffer where the authentecation tag will be written. Must be
 *   `RC_AEAD_XCHACHA20POLY1305_MACBYTES` bytes in length.
 * - `nonce`: a number used once, AKA initialization vector. This does not have to be
 *   confidential and can be stored with the message; however, it may not be reused
 *   for further encryption. Must be
 *   `RC_AEAD_XCHACHA20POLY1305_NONCEBYTES` bytes in length.
 * - `key`: the key used to encrypt the message. Must be
 *   `RC_AEAD_XCHACHA20POLY1305_KEYBYTES` bytes in length.
 *
 * # SAFETY
 *
 * `msg` must point to a valid buffer that is at least `mlen` in length.
 */
int8_t rc_aead_xchacha20poly1305_encrypt(uint8_t *msg,
                                         uintptr_t mlen,
                                         uint8_t mac[RC_AEAD_XCHACHA20POLY1305_MACBYTES],
                                         const uint8_t nonce[RC_AEAD_XCHACHA20POLY1305_NONCEBYTES],
                                         const uint8_t key[RC_AEAD_XCHACHA20POLY1305_KEYBYTES]);

int8_t rc_aead_xchacha20poly1305_encrypt_ad(uint8_t *msg,
                                            uintptr_t mlen,
                                            uint8_t mac[RC_AEAD_XCHACHA20POLY1305_MACBYTES],
                                            const uint8_t nonce[RC_AEAD_XCHACHA20POLY1305_NONCEBYTES],
                                            const uint8_t key[RC_AEAD_XCHACHA20POLY1305_KEYBYTES],
                                            const uint8_t *ad,
                                            uintptr_t adlen);

/**
 * Decrypt a message using the XChaCha20-Poly1305 algorithm.
 *
 * Returns 0 if successful, -1 otherwise. Parameters:
 *
 * - `msg`: an input and output buffer that will be decrypted
 * - `mlen`: length of the message to be decrypted
 * - `mac`: an output buffer where the authentecation tag will be written. Must be
 *   `RC_AEAD_XCHACHA20POLY1305_MACBYTES` bytes in length.
 * - `nonce`: a number used once, AKA initialization vector. This does not have to be
 *   confidential and can be stored with the message; however, it may not be reused
 *   for further encryption. Must be
 *   `RC_AEAD_XCHACHA20POLY1305_NONCEBYTES` bytes in length.
 * - `key`: the key used to encrypt the message. Must be
 *   `RC_AEAD_XCHACHA20POLY1305_KEYBYTES` bytes in length.
 *
 * # SAFETY
 *
 * `msg` must point to a valid buffer that is at least `mlen` in length.
 */
int8_t rc_aead_xchacha20poly1305_decrypt(uint8_t *msg,
                                         uintptr_t mlen,
                                         const uint8_t mac[RC_AEAD_XCHACHA20POLY1305_MACBYTES],
                                         const uint8_t nonce[RC_AEAD_XCHACHA20POLY1305_NONCEBYTES],
                                         const uint8_t key[RC_AEAD_XCHACHA20POLY1305_KEYBYTES]);

int8_t rc_aead_xchacha20poly1305_decrypt_ad(uint8_t *msg,
                                            uintptr_t mlen,
                                            const uint8_t mac[RC_AEAD_XCHACHA20POLY1305_MACBYTES],
                                            const uint8_t nonce[RC_AEAD_XCHACHA20POLY1305_NONCEBYTES],
                                            const uint8_t key[RC_AEAD_XCHACHA20POLY1305_KEYBYTES],
                                            const uint8_t *ad,
                                            uintptr_t adlen);

/**
 * Generate a nonce suitible for use with the
 *XSalsa20-Poly1305
 * algorithm.
 */
void rc_secretbox_keygen(uint8_t nonce[RC_SECRETBOX_KEYBYTES]);

/**
 * Generate a key suitible for use with the
 *XSalsa20-Poly1305
 * algorithm.
 */
void rc_secretbox_noncegen(uint8_t key[RC_SECRETBOX_NONCEBYTES]);

/**
 * Encrypt a message using the XSalsa20-Poly1305 algorithm.
 *
 * Returns 0 if successful, -1 otherwise. Parameters:
 *
 * - `msg`: an input and output buffer that will be encrypted
 * - `mlen`: length of the message to be encrypted
 * - `mac`: an output buffer where the authentecation tag will be written. Must be
 *   `RC_SECRETBOX_MACBYTES` bytes in length.
 * - `nonce`: a number used once, AKA initialization vector. This does not have to be
 *   confidential and can be stored with the message; however, it may not be reused
 *   for further encryption. Must be
 *   `RC_SECRETBOX_KEYBYTES` bytes in length.
 * - `key`: the key used to encrypt the message. Must be
 *   `RC_SECRETBOX_NONCEBYTES` bytes in length.
 *
 * # SAFETY
 *
 * `msg` must point to a valid buffer that is at least `mlen` in length.
 */
int8_t rc_secretbox_detached(uint8_t *msg,
                             uintptr_t mlen,
                             uint8_t mac[RC_SECRETBOX_MACBYTES],
                             const uint8_t nonce[RC_SECRETBOX_KEYBYTES],
                             const uint8_t key[RC_SECRETBOX_NONCEBYTES]);

int8_t rc_secretbox_detached_ad(uint8_t *msg,
                                uintptr_t mlen,
                                uint8_t mac[RC_SECRETBOX_MACBYTES],
                                const uint8_t nonce[RC_SECRETBOX_KEYBYTES],
                                const uint8_t key[RC_SECRETBOX_NONCEBYTES],
                                const uint8_t *ad,
                                uintptr_t adlen);

/**
 * Decrypt a message using the XSalsa20-Poly1305 algorithm.
 *
 * Returns 0 if successful, -1 otherwise. Parameters:
 *
 * - `msg`: an input and output buffer that will be decrypted
 * - `mlen`: length of the message to be decrypted
 * - `mac`: an output buffer where the authentecation tag will be written. Must be
 *   `RC_SECRETBOX_MACBYTES` bytes in length.
 * - `nonce`: a number used once, AKA initialization vector. This does not have to be
 *   confidential and can be stored with the message; however, it may not be reused
 *   for further encryption. Must be
 *   `RC_SECRETBOX_KEYBYTES` bytes in length.
 * - `key`: the key used to encrypt the message. Must be
 *   `RC_SECRETBOX_NONCEBYTES` bytes in length.
 *
 * # SAFETY
 *
 * `msg` must point to a valid buffer that is at least `mlen` in length.
 */
int8_t rc_secretbox_open_detached(uint8_t *msg,
                                  uintptr_t mlen,
                                  const uint8_t mac[RC_SECRETBOX_MACBYTES],
                                  const uint8_t nonce[RC_SECRETBOX_KEYBYTES],
                                  const uint8_t key[RC_SECRETBOX_NONCEBYTES]);

int8_t rc_secretbox_open_detached_ad(uint8_t *msg,
                                     uintptr_t mlen,
                                     const uint8_t mac[RC_SECRETBOX_MACBYTES],
                                     const uint8_t nonce[RC_SECRETBOX_KEYBYTES],
                                     const uint8_t key[RC_SECRETBOX_NONCEBYTES],
                                     const uint8_t *ad,
                                     uintptr_t adlen);

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus
