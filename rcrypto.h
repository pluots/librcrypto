/*
* This file is automatically generated upon running
* `cargo +nightly build`. Do not modify by hand.
*/
#define X 100
#define RC_AEAD_AES128GCM_NONCEBYTES 12
#define RC_AEAD_AES128GCM_KEYBYTES 16
#define RC_AEAD_AES128GCM_MACBYTES 16
#define RC_AEAD_AES256GCM_NONCEBYTES 12
#define RC_AEAD_AES256GCM_KEYBYTES 32
#define RC_AEAD_AES256GCM_MACBYTES 16
#define RC_AEAD_CHACHA20POLY1305_NONCEBYTES 12
#define RC_AEAD_CHACHA20POLY1305_KEYBYTES 32
#define RC_AEAD_CHACHA20POLY1305_MACBYTES 16
#define RC_AEAD_XCHACHA20POLY1305_NONCEBYTES 24
#define RC_AEAD_XCHACHA20POLY1305_KEYBYTES 32
#define RC_AEAD_XCHACHA20POLY1305_MACBYTES 16
#define RC_SECRETBOX_KEYBYTES 24
#define RC_SECRETBOX_NONCEBYTES 32
#define RC_SECRETBOX_MACBYTES 16


#include <stdint.h>



#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Generate a nonce suitible for use with the
 *AES128-GCM
 * algorithm.
 */
void rc_aead_aes128gcm_noncegen(uint8_t (*nonce)[RC_AEAD_AES128GCM_NONCEBYTES]);

/**
 * Generate a key suitible for use with the
 *AES128-GCM
 * algorithm.
 */
void rc_aead_aes128gcm_keygen(uint8_t (*key)[RC_AEAD_AES128GCM_KEYBYTES]);

/**
 * Encrypt a message using the AES128-GCM algorithm.
 *
 * Returns 0 if successful, -1 otherwise. Parameters:
 *
 * - `msg`: an input and output buffer that will be encrypted
 * - `mlen`: length of the message to be encrypted
 * - `mac`: an output buffer where the authentecation tag will be written. Must be
 *   `RC_AEAD_AES128GCM_MACBYTES` bytes in length.
 * - `nonce`: a number used once, AKA initialization vector. This does not have to be
 *   confidential and can be stored with the message; however, it may not be reused
 *   for further encryption. Must be
 *   `RC_AEAD_AES128GCM_NONCEBYTES` bytes in length.
 * - `key`: the key used to encrypt the message. Must be
 *   `RC_AEAD_AES128GCM_KEYBYTES` bytes in length.
 *
 * # SAFETY
 *
 * `msg` must point to a valid buffer that is at least `mlen` in length.
 */
short rc_aead_aes128gcm_encrypt(uint8_t *msg,
                                uintptr_t mlen,
                                uint8_t (*mac)[RC_AEAD_AES128GCM_MACBYTES],
                                const uint8_t (*nonce)[RC_AEAD_AES128GCM_NONCEBYTES],
                                const uint8_t (*key)[RC_AEAD_AES128GCM_KEYBYTES]);

/**
 * Decrypt a message using the AES128-GCM algorithm.
 *
 * Returns 0 if successful, -1 otherwise. Parameters:
 *
 * - `msg`: an input and output buffer that will be decrypted
 * - `mlen`: length of the message to be decrypted
 * - `mac`: an output buffer where the authentecation tag will be written. Must be
 *   `RC_AEAD_AES128GCM_MACBYTES` bytes in length.
 * - `nonce`: a number used once, AKA initialization vector. This does not have to be
 *   confidential and can be stored with the message; however, it may not be reused
 *   for further encryption. Must be
 *   `RC_AEAD_AES128GCM_NONCEBYTES` bytes in length.
 * - `key`: the key used to encrypt the message. Must be
 *   `RC_AEAD_AES128GCM_KEYBYTES` bytes in length.
 *
 * # SAFETY
 *
 * `msg` must point to a valid buffer that is at least `mlen` in length.
 */
short rc_aead_aes128gcm_decrypt(uint8_t *msg,
                                uintptr_t mlen,
                                const uint8_t (*mac)[RC_AEAD_AES128GCM_MACBYTES],
                                const uint8_t (*nonce)[RC_AEAD_AES128GCM_NONCEBYTES],
                                const uint8_t (*key)[RC_AEAD_AES128GCM_KEYBYTES]);

/**
 * Generate a nonce suitible for use with the
 *AES256-GCM
 * algorithm.
 */
void rc_aead_aes256gcm_noncegen(uint8_t (*nonce)[RC_AEAD_AES256GCM_NONCEBYTES]);

/**
 * Generate a key suitible for use with the
 *AES256-GCM
 * algorithm.
 */
void rc_aead_aes256gcm_keygen(uint8_t (*key)[RC_AEAD_AES256GCM_KEYBYTES]);

/**
 * Encrypt a message using the AES256-GCM algorithm.
 *
 * Returns 0 if successful, -1 otherwise. Parameters:
 *
 * - `msg`: an input and output buffer that will be encrypted
 * - `mlen`: length of the message to be encrypted
 * - `mac`: an output buffer where the authentecation tag will be written. Must be
 *   `RC_AEAD_AES256GCM_MACBYTES` bytes in length.
 * - `nonce`: a number used once, AKA initialization vector. This does not have to be
 *   confidential and can be stored with the message; however, it may not be reused
 *   for further encryption. Must be
 *   `RC_AEAD_AES256GCM_NONCEBYTES` bytes in length.
 * - `key`: the key used to encrypt the message. Must be
 *   `RC_AEAD_AES256GCM_KEYBYTES` bytes in length.
 *
 * # SAFETY
 *
 * `msg` must point to a valid buffer that is at least `mlen` in length.
 */
short rc_aead_aes256gcm_encrypt(uint8_t *msg,
                                uintptr_t mlen,
                                uint8_t (*mac)[RC_AEAD_AES256GCM_MACBYTES],
                                const uint8_t (*nonce)[RC_AEAD_AES256GCM_NONCEBYTES],
                                const uint8_t (*key)[RC_AEAD_AES256GCM_KEYBYTES]);

/**
 * Decrypt a message using the AES256-GCM algorithm.
 *
 * Returns 0 if successful, -1 otherwise. Parameters:
 *
 * - `msg`: an input and output buffer that will be decrypted
 * - `mlen`: length of the message to be decrypted
 * - `mac`: an output buffer where the authentecation tag will be written. Must be
 *   `RC_AEAD_AES256GCM_MACBYTES` bytes in length.
 * - `nonce`: a number used once, AKA initialization vector. This does not have to be
 *   confidential and can be stored with the message; however, it may not be reused
 *   for further encryption. Must be
 *   `RC_AEAD_AES256GCM_NONCEBYTES` bytes in length.
 * - `key`: the key used to encrypt the message. Must be
 *   `RC_AEAD_AES256GCM_KEYBYTES` bytes in length.
 *
 * # SAFETY
 *
 * `msg` must point to a valid buffer that is at least `mlen` in length.
 */
short rc_aead_aes256gcm_decrypt(uint8_t *msg,
                                uintptr_t mlen,
                                const uint8_t (*mac)[RC_AEAD_AES256GCM_MACBYTES],
                                const uint8_t (*nonce)[RC_AEAD_AES256GCM_NONCEBYTES],
                                const uint8_t (*key)[RC_AEAD_AES256GCM_KEYBYTES]);

/**
 * Generate a nonce suitible for use with the
 *ChaCha20-Poly1305
 * algorithm.
 */
void rc_aead_chacha20poly1305_noncegen(uint8_t (*nonce)[RC_AEAD_CHACHA20POLY1305_NONCEBYTES]);

/**
 * Generate a key suitible for use with the
 *ChaCha20-Poly1305
 * algorithm.
 */
void rc_aead_chacha20poly1305_keygen(uint8_t (*key)[RC_AEAD_CHACHA20POLY1305_KEYBYTES]);

/**
 * Encrypt a message using the ChaCha20-Poly1305 algorithm.
 *
 * Returns 0 if successful, -1 otherwise. Parameters:
 *
 * - `msg`: an input and output buffer that will be encrypted
 * - `mlen`: length of the message to be encrypted
 * - `mac`: an output buffer where the authentecation tag will be written. Must be
 *   `RC_AEAD_CHACHA20POLY1305_MACBYTES` bytes in length.
 * - `nonce`: a number used once, AKA initialization vector. This does not have to be
 *   confidential and can be stored with the message; however, it may not be reused
 *   for further encryption. Must be
 *   `RC_AEAD_CHACHA20POLY1305_NONCEBYTES` bytes in length.
 * - `key`: the key used to encrypt the message. Must be
 *   `RC_AEAD_CHACHA20POLY1305_KEYBYTES` bytes in length.
 *
 * # SAFETY
 *
 * `msg` must point to a valid buffer that is at least `mlen` in length.
 */
short rc_aead_chacha20poly1305_encrypt(uint8_t *msg,
                                       uintptr_t mlen,
                                       uint8_t (*mac)[RC_AEAD_CHACHA20POLY1305_MACBYTES],
                                       const uint8_t (*nonce)[RC_AEAD_CHACHA20POLY1305_NONCEBYTES],
                                       const uint8_t (*key)[RC_AEAD_CHACHA20POLY1305_KEYBYTES]);

/**
 * Decrypt a message using the ChaCha20-Poly1305 algorithm.
 *
 * Returns 0 if successful, -1 otherwise. Parameters:
 *
 * - `msg`: an input and output buffer that will be decrypted
 * - `mlen`: length of the message to be decrypted
 * - `mac`: an output buffer where the authentecation tag will be written. Must be
 *   `RC_AEAD_CHACHA20POLY1305_MACBYTES` bytes in length.
 * - `nonce`: a number used once, AKA initialization vector. This does not have to be
 *   confidential and can be stored with the message; however, it may not be reused
 *   for further encryption. Must be
 *   `RC_AEAD_CHACHA20POLY1305_NONCEBYTES` bytes in length.
 * - `key`: the key used to encrypt the message. Must be
 *   `RC_AEAD_CHACHA20POLY1305_KEYBYTES` bytes in length.
 *
 * # SAFETY
 *
 * `msg` must point to a valid buffer that is at least `mlen` in length.
 */
short rc_aead_chacha20poly1305_decrypt(uint8_t *msg,
                                       uintptr_t mlen,
                                       const uint8_t (*mac)[RC_AEAD_CHACHA20POLY1305_MACBYTES],
                                       const uint8_t (*nonce)[RC_AEAD_CHACHA20POLY1305_NONCEBYTES],
                                       const uint8_t (*key)[RC_AEAD_CHACHA20POLY1305_KEYBYTES]);

/**
 * Generate a nonce suitible for use with the
 *XChaCha20-Poly1305
 * algorithm.
 */
void rc_aead_xchacha20poly1305_noncegen(uint8_t (*nonce)[RC_AEAD_XCHACHA20POLY1305_NONCEBYTES]);

/**
 * Generate a key suitible for use with the
 *XChaCha20-Poly1305
 * algorithm.
 */
void rc_aead_xchacha20poly1305_keygen(uint8_t (*key)[RC_AEAD_XCHACHA20POLY1305_KEYBYTES]);

/**
 * Encrypt a message using the XChaCha20-Poly1305 algorithm.
 *
 * Returns 0 if successful, -1 otherwise. Parameters:
 *
 * - `msg`: an input and output buffer that will be encrypted
 * - `mlen`: length of the message to be encrypted
 * - `mac`: an output buffer where the authentecation tag will be written. Must be
 *   `RC_AEAD_XCHACHA20POLY1305_MACBYTES` bytes in length.
 * - `nonce`: a number used once, AKA initialization vector. This does not have to be
 *   confidential and can be stored with the message; however, it may not be reused
 *   for further encryption. Must be
 *   `RC_AEAD_XCHACHA20POLY1305_NONCEBYTES` bytes in length.
 * - `key`: the key used to encrypt the message. Must be
 *   `RC_AEAD_XCHACHA20POLY1305_KEYBYTES` bytes in length.
 *
 * # SAFETY
 *
 * `msg` must point to a valid buffer that is at least `mlen` in length.
 */
short rc_aead_xchacha20poly1305_encrypt(uint8_t *msg,
                                        uintptr_t mlen,
                                        uint8_t (*mac)[RC_AEAD_XCHACHA20POLY1305_MACBYTES],
                                        const uint8_t (*nonce)[RC_AEAD_XCHACHA20POLY1305_NONCEBYTES],
                                        const uint8_t (*key)[RC_AEAD_XCHACHA20POLY1305_KEYBYTES]);

/**
 * Decrypt a message using the XChaCha20-Poly1305 algorithm.
 *
 * Returns 0 if successful, -1 otherwise. Parameters:
 *
 * - `msg`: an input and output buffer that will be decrypted
 * - `mlen`: length of the message to be decrypted
 * - `mac`: an output buffer where the authentecation tag will be written. Must be
 *   `RC_AEAD_XCHACHA20POLY1305_MACBYTES` bytes in length.
 * - `nonce`: a number used once, AKA initialization vector. This does not have to be
 *   confidential and can be stored with the message; however, it may not be reused
 *   for further encryption. Must be
 *   `RC_AEAD_XCHACHA20POLY1305_NONCEBYTES` bytes in length.
 * - `key`: the key used to encrypt the message. Must be
 *   `RC_AEAD_XCHACHA20POLY1305_KEYBYTES` bytes in length.
 *
 * # SAFETY
 *
 * `msg` must point to a valid buffer that is at least `mlen` in length.
 */
short rc_aead_xchacha20poly1305_decrypt(uint8_t *msg,
                                        uintptr_t mlen,
                                        const uint8_t (*mac)[RC_AEAD_XCHACHA20POLY1305_MACBYTES],
                                        const uint8_t (*nonce)[RC_AEAD_XCHACHA20POLY1305_NONCEBYTES],
                                        const uint8_t (*key)[RC_AEAD_XCHACHA20POLY1305_KEYBYTES]);

/**
 * Generate a nonce suitible for use with the
 *XSalsa20-Poly1305
 * algorithm.
 */
void rc_secretbox_keygen(uint8_t (*nonce)[RC_SECRETBOX_KEYBYTES]);

/**
 * Generate a key suitible for use with the
 *XSalsa20-Poly1305
 * algorithm.
 */
void rc_secretbox_noncegen(uint8_t (*key)[RC_SECRETBOX_NONCEBYTES]);

/**
 * Encrypt a message using the XSalsa20-Poly1305 algorithm.
 *
 * Returns 0 if successful, -1 otherwise. Parameters:
 *
 * - `msg`: an input and output buffer that will be encrypted
 * - `mlen`: length of the message to be encrypted
 * - `mac`: an output buffer where the authentecation tag will be written. Must be
 *   `RC_SECRETBOX_MACBYTES` bytes in length.
 * - `nonce`: a number used once, AKA initialization vector. This does not have to be
 *   confidential and can be stored with the message; however, it may not be reused
 *   for further encryption. Must be
 *   `RC_SECRETBOX_KEYBYTES` bytes in length.
 * - `key`: the key used to encrypt the message. Must be
 *   `RC_SECRETBOX_NONCEBYTES` bytes in length.
 *
 * # SAFETY
 *
 * `msg` must point to a valid buffer that is at least `mlen` in length.
 */
short rc_secretbox_detached(uint8_t *msg,
                            uintptr_t mlen,
                            uint8_t (*mac)[RC_SECRETBOX_MACBYTES],
                            const uint8_t (*nonce)[RC_SECRETBOX_KEYBYTES],
                            const uint8_t (*key)[RC_SECRETBOX_NONCEBYTES]);

/**
 * Decrypt a message using the XSalsa20-Poly1305 algorithm.
 *
 * Returns 0 if successful, -1 otherwise. Parameters:
 *
 * - `msg`: an input and output buffer that will be decrypted
 * - `mlen`: length of the message to be decrypted
 * - `mac`: an output buffer where the authentecation tag will be written. Must be
 *   `RC_SECRETBOX_MACBYTES` bytes in length.
 * - `nonce`: a number used once, AKA initialization vector. This does not have to be
 *   confidential and can be stored with the message; however, it may not be reused
 *   for further encryption. Must be
 *   `RC_SECRETBOX_KEYBYTES` bytes in length.
 * - `key`: the key used to encrypt the message. Must be
 *   `RC_SECRETBOX_NONCEBYTES` bytes in length.
 *
 * # SAFETY
 *
 * `msg` must point to a valid buffer that is at least `mlen` in length.
 */
short rc_secretbox_open_detached(uint8_t *msg,
                                 uintptr_t mlen,
                                 const uint8_t (*mac)[RC_SECRETBOX_MACBYTES],
                                 const uint8_t (*nonce)[RC_SECRETBOX_KEYBYTES],
                                 const uint8_t (*key)[RC_SECRETBOX_NONCEBYTES]);

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus
