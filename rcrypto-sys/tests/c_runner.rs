// Setup lives in this file

use std::env;
use std::path::Path;
use std::process::{Command, Stdio};
use std::sync::Once;

static MAKE: Once = Once::new();

fn run_setup() {
    let out_dir = env!("OUT_DIR");
    let crate_dir = Path::new(env!("CARGO_MANIFEST_DIR"));
    let test_dir = crate_dir.join("tests");

    MAKE.call_once(|| {
        println!("using output directory {out_dir}");
        let mut cmd = Command::new("make");
        cmd.args(
            [
                "-C",
                &test_dir.to_string_lossy(),
                &format!("OUT_DIR={out_dir}"),
            ]
            .as_slice(),
        );
        cmd.stdout(Stdio::inherit());
        cmd.stderr(Stdio::inherit());
        let out = cmd.output().expect("failed to run Makefile");
        assert!(out.stdout.is_empty());
        assert!(out.stderr.is_empty());
    })
}

/// Run a command, if it fails print its output
fn run_cmd_else_quit(cmd: &mut Command, fname: &str) {
    let out = cmd
        .output()
        .unwrap_or_else(|e| panic!("failed to run command {cmd:?}: {e}"));

    let stdout = String::from_utf8_lossy(&out.stdout);
    let stderr = String::from_utf8_lossy(&out.stderr);

    let combined = format!("{stdout}{stderr}");
    let mut has_failures = false;

    if combined.contains("IGNORE") || combined.contains("FAIL") || combined.contains("PASS") {
        // using output from unity, format it nicely
        println!("> -------- unity ignored --------");
        combined
            .lines()
            .filter(|line| line.contains("IGNORE"))
            .for_each(|line| println!("> {line}"));

        println!("\n> -------- unity failures --------");
        combined
            .lines()
            .filter(|line| line.contains("FAIL"))
            .for_each(|line| {
                println!("> {line}");
                has_failures = true;
            });

        println!("\n> -------- unity passed --------");
        combined
            .lines()
            .filter(|line| line.contains("PASS"))
            .for_each(|line| println!("> {line}"));
    } else {
        // For other failures, just propegate the output
        println!("{stdout}");
        eprintln!("{stderr}");
    }

    println!();

    if !out.status.success() || has_failures {
        panic!("{fname} failed with status {}", out.status);
    }
}

// include tests generated by `build.rs`, C test suite runner
include!(concat!(env!("OUT_DIR"), "/auto_suite.rs"));
