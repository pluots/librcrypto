use std::fmt::Write;
use std::path::{Path, PathBuf};
use std::{env, fs};

use indoc::indoc;

fn main() {
    update_tests();
}

const TEST_PREFIX: &str = "// autogenerated file, do not edit manually
// one test is generated for each `.c` file


";

#[cfg(windows)]
const EXE_EXTENSION: &str = "exe";
#[cfg(not(windows))]
const EXE_EXTENSION: &str = "out";

/// Autogenerate an integration test for every `.c` file
/// Make builds the tests, we just invoke them
fn update_tests() {
    let crate_dir = Path::new(env!("CARGO_MANIFEST_DIR"));
    let out_dir = PathBuf::from(&env::var("OUT_DIR").unwrap());
    let out_file = out_dir.join("auto_suite.rs");
    let test_dir = crate_dir.join("tests");
    // println!("cargo:rerun-if-changed={}", suite_dir.to_string_lossy());
    let test_paths = fs::read_dir(&test_dir).unwrap();

    let mut to_write = TEST_PREFIX.to_owned();

    indoc::writedoc!(
        to_write,
        "
            // use std::io::prelude::*;
            use std::process::Command;
            use std::sync::Once;

            static MAKE: Once = Once::new();

            fn run_setup() {{
                MAKE.call_once(|| {{
                    let mut cmd = Command::new(\"make\");
                    cmd.args([\"-C\", \"{test_dir}\"].as_slice());
                    cmd.env(\"OUT_DIR\", \"{out_dir}\");
                    run_cmd_else_quit(&mut cmd, \"makefile\");
                }})
            }}

            /// Run a command, if it fails print its output
            fn run_cmd_else_quit(cmd: &mut Command, fname: &str) {{
                let out = cmd
                    .output()
                    .unwrap_or_else(|e| panic!(\"failed to run command {{cmd:?}}: {{e}}\"));

                let stdout = String::from_utf8_lossy(&out.stdout);
                let stderr = String::from_utf8_lossy(&out.stderr);

                let combined = format!(\"{{stdout}}{{stderr}}\");
                let mut has_failures = false;

                if combined.contains(\"IGNORE\") ||
                    combined.contains(\"FAIL\") ||
                    combined.contains(\"PASS\")
                {{
                    // using output from unity, format it nicely
                    println!(\"    -------- unity ignores --------\");
                    combined.lines()
                        .filter(|line| line.contains(\"IGNORE\"))
                        .for_each(|line| println!(\"    {{line}}\"));
        
                    println!(\n\"    -------- unity failures --------\");
                    combined.lines()
                        .filter(|line| line.contains(\"FAIL\"))
                        .for_each(|line| {{
                            println!(\"    {{line}}\");
                            has_failures = true;
                        }});

                    println!(\n\"    -------- unity passed --------\");
                    combined.lines()
                        .filter(|line| line.contains(\"PASS\"))
                        .for_each(|line| println!(\"    {{line}}\"));
                }}

                println!();
        
                if !out.status.success() || has_failures {{
                    panic!(\"{{fname}} failed with status {{}}\", out.status);
                }}
            }}
        ",
        test_dir = test_dir.to_string_lossy(),
        out_dir = out_dir.to_string_lossy(),
    )
    .unwrap();

    for path in test_paths {
        let path = path.unwrap().path();
        let fname = path.file_name().unwrap().to_string_lossy();
        if !fname.ends_with(".c") {
            continue;
        }

        let test_name = fname.strip_suffix(".c").unwrap().replace('-', "_");
        let exe_path = format!(
            "{out_dir}/c-out/test_{test_name}.{EXE_EXTENSION}",
            out_dir = out_dir.to_string_lossy()
        );

        write!(
            to_write,
            indoc! {"

                #[test]
                fn test_{test_name}() {{
                    run_setup();
                    let mut cmd = Command::new(\"{exe_path}\");
                    run_cmd_else_quit(&mut cmd, \"{fname}\");
                }}
            "},
            test_name = test_name,
            exe_path = exe_path,
            fname = fname,
        )
        .unwrap();
    }

    fs::write(out_file, to_write).unwrap();
}
